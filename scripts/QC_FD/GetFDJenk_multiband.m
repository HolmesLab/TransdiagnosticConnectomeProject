function fd = GetFDJenk_multiband(mov, TR, k, stopband, head)	% This function computes framewise displacement according to the Jenkinson method.     % The FD at a given timepoint is traditionally computed as the    % difference in head position at time i and time i-1. This code allows    % one to set the delay, so FD can be computed as the difference in head    % position between time i and time i-k. This is useful for dealing with    % multiband data, where the motion traces should be filtered and FD    % computed over longer delays to allow more interpretable motion    % estimates, as described in Power et al. (2019) NeuroImage, 116041.    %    % Note that here we use the Jenkinson et al. formulation of FD, whereas    % the Power article uses his own formualtion. The two are highly    % correlated.	%	% ------	% INPUTS	% ------	% mov       - an N x 6 matrix containing 6 movement parameters and where     %             N = length of the time series.    % TR        - TR of scan in seconds	% k         - TR difference for computing displacement. For e.g., if     %             k=3, the position at each timepoint will be compared to     %             the position at the timepoint 3 TRs prior. Should ideally     %             be set so the effective TR is 2 < k*TR < 3. Default is    %             k=3. Note: k=1 returns standard FD estimate.    % stopband  - vector of 2 numbers representing the cut-off frequencies    %             for the stopband. Frequencies in this band will be    %             filtered out. Default = [0.2 0.5], as suggested by Power    %             et al. If no filtering is desired, set stopband = [].    % head      - head radius (in mm). Default = 80mm, as in Yan/FSL.    %	% -------	% OUTPUTS	% -------	% fd        - N-1 length vector representing the total framewise	%           displacement. There will be k zeros at the start of the	%           vector.    %    % Calls additional function GetTMat.m	%    % Original FD code:	% Linden Parkes & Ben Fulcher, Brain & Mental Health Laboratory, 2016    %    % Updated to to handle multiband data:    % Linden Parkes, Sidhant Chopra, Tribikram Thapa, & Alex Fornito 2020	% =====================================================================            % ---------------------------------------------------------------------    % Set defaults    % ---------------------------------------------------------------------        fprintf(1,'Computing Jenkinson''s framewise displacement...');        % set defaults    if nargin < 3        k=3;        stopband = [0.2 0.5];        head = 80;    elseif nargin<4          stopband = [0.2 0.5];        head = 80;    elseif nargin<5        head = 80;    end        % ---------------------------------------------------------------------    % Detrend and filter motion parameters    % ---------------------------------------------------------------------        if ~isempty(stopband)        % construct temporal filter        nyq = (1/TR)/2;                     %  nyquist        Wn = stopband./nyq;                 %  cutoff frequencies        order = 10;                         %  controls steepness of filter roll-off. Set to same value as in Power et al.        [B, A] = butter(order,Wn,'stop');   %  construct filter        % detrend and filter motion parameters        mov = detrend(mov,'linear');        mov = filtfilt(B, A, mov);    else        % detrend only if no filter desired        mov = detrend(mov,'linear');    end        % ---------------------------------------------------------------------    % Get FD    % ---------------------------------------------------------------------        % number of time points    N = size(mov,1);    % initialise fd variable.    fd = zeros(N,1);    % start at volume 2    for i = k+1:N % loop from k+1 (e.g., if k = 1, loop runs 2:N as per original code)    	% rigid body transform mat from time point i    	T = GetTMat(mov(i,:));    	% rigid body transform mat from time point i-k    	T_k = GetTMat(mov(i-k,:));     	Y = T * inv(T_k) - eye(size(T));    	A = Y(1:3,1:3);    	b = Y(1:3,4);    	x = mov(i,1); y = mov(i,2); z = mov(i,3);    	m = b + A * [x; y; z];    	% store in i slot. e.g., for k=1, fd(1) = displacement difference betwen timepoint 2 and timepoint 1    	fd(i) = sqrt(1/5 * head^2 * trace(A'*A) + m'*m);    end    	    fprintf(1,' done\n');