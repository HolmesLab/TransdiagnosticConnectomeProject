# !/bin/bash
# Script to create physiological masks following HCP post minimal preprocessing best practices.
# Adapted from scripts by MW Cole, R Mill, & T Ito; modified by C. Cocuzza 2023 for TCP Data Release, Holmes Lab.

# Usage: create physiological masks to later be used in aCompCor portion of nuisance regression;
# this denoising method follows recommendations by Ciric et al., 2017.
# Motion regressors will also be used, but those are already generated by hcp pipelines.

# NOTE: each time masks are resampled to functional space, it is done separately for AP/PA phase encoding directions; 
# make sure this is also done for the nuisance regression scripts 

# NOTE: use 2nd input variable (runName) to specify different versions of files (e.g., ICA-FIX'd, non-denoised, etc.).
# This will also be used in the saving of files, so they are differentiated. 
# Some examples: <run_name>_bold <run_name>_bold_hp2000_clean
# Best scenario: there are corresponding .nii.gz volume files and .dtseries.nii surface files. 

####################################################################################################
# Set variables 

# User parameter options:
# NOTE: might want to clean this up to be in the --input format

# First input: subject ID; full subject string, for example: "sub-PCM001" or "sub-PCY001"
subj=$1
if [ -z "$subj" ]; then 
    echo "No subject ID specified, please use 'bash create_masks_HCP.sh <subject ID>' and re-run. Terminating shell script."
    exit
fi 

# Second input: functional run name that matches the string used in HCP minimal preprocessing and used for directory naming.
# NOTE: This may match the 3rd input below exactly, but sometimes the file name functional run string has more 
# suffixes, so these are separate inputs to allow flexibility. 
runName_Directory=$2
if [ -z "$runName_Directory" ]; then 
    echo "No functional run name (for HCP directory) specified, please specify and re-run. Terminating shell script."
    exit
fi 

# Third input: functional run name that matches the string used in HCP minimal preprocessing and used for file saving.
# NOTE: This may have added suffixes like "_hp2000" that aren't in the 2nd input variable above.
runName_TimeSeriesFile=$3
if [ -z "$runName_TimeSeriesFile" ]; then 
    echo "No functional run name (for timeseries file and output file) specified, please specify and re-run. Terminating shell script."
    exit
fi 

# Fourth input: input directory (full path); every subfolder before subject ID 
# TCP input directory: /gpfs/milgram/project/holmes/PsychConnectome/MRI_Data/fmri_analysis/derivatives/hcp/
basedir_input=$4
if [ -z "$basedir_input" ]; then 
    echo "No input directory specified, please specify and re-run. Terminating shell script."
    exit
fi 

# Fifth input: output directory (full path)
# TCP output directory: /gpfs/milgram/project/holmes/PsychConnectome/MRI_Data/fmri_analysis/derivatives/post_hcp/
basedir_output=$5
if [ -z "$basedir_output" ]; then 
    echo "No output directory specified, please specify and re-run. Terminating shell script."
    exit
fi 

module load AFNI

####################################################################################################
# Subject input directory

subjdir="${basedir_input}/${subj}/"
#if [ ! -e $subjdir ]; then mkdir -p $subjdir; fi
if [ ! -e $subjdir ]; then 
    echo "$subjdir does not exist, please check directory and/or subject ID. Terminating shell script."
    exit
fi

# Subject output directory 
subjmaskdir="${basedir_output}/${subj}/masks/"
#echo $subjmaskdir
if [ ! -e $subjmaskdir ]; then
    echo "$subjmaskdir does not yet exist, creating it now..."
    mkdir $subjmaskdir
fi

####################################################################################################
# Create masks
# HCP standard to parcel out white v gray v ventricle matter

echo "Creating gray, white, ventricle, whole brain masks for subject ${subj}..."

####################################################################################################
### Set up files and directories 
segparc_orig="${subjdir}/MNINonLinear/wmparc.nii.gz"
cp $segparc_orig $subjmaskdir

cd $subjmaskdir

segparc="${subjmaskdir}/wmparc.nii.gz"

func_str="${runName_TimeSeriesFile}"
#func_run="${subjmaskdir}${func_str}.nii.gz"
func_run="${subjdir}/MNINonLinear/Results/${runName_Directory}/${func_str}.nii.gz"

####################################################################################################
### Create whole brain masks
echo "Creating whole brain mask for subject ${subj}..."

3dcalc -overwrite -a $segparc -expr 'ispositive(a)' -prefix ${subj}_wholebrainmask.nii.gz

# Resample to functional space (func in MNI space)
3dresample -overwrite -master $func_run -inset ${subj}_wholebrainmask.nii.gz -prefix ${subj}_${func_str}_wholebrainmask_func.nii.gz

# Dilate mask by 1 functional voxel (just in case the resampled anatomical mask is off by a bit)
3dLocalstat -overwrite -nbhd 'SPHERE(-1)' -stat 'max' -prefix ${subj}_${func_str}_wholebrainmask_func_dil1vox.nii.gz ${subj}_${func_str}_wholebrainmask_func.nii.gz

####################################################################################################
### Create gray matter masks
echo "Creating gray matter masks for subject ${subj}..." 

# Indicate the mask value set for wmparc.nii.gz: gray matter mask set
maskValSet="8 9 10 11 12 13 16 17 18 19 20 26 27 28 47 48 49 50 51 52 53 54 55 56 58 59 60 96 97 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035"

# Add segments to mask
maskNum=1
for maskval in $maskValSet
do
if [ ${maskNum} = 1 ]; then
        3dcalc -a $segparc -expr "equals(a,${maskval})" -prefix ${subj}mask_temp.nii.gz -overwrite
    else
        3dcalc -a $segparc -b ${subj}mask_temp.nii.gz -expr "equals(a,${maskval})+b" -prefix ${subj}mask_temp.nii.gz -overwrite
    fi
let maskNum++
done

# Make mask binary
3dcalc -a ${subj}mask_temp.nii.gz -expr 'ispositive(a)' -prefix ${subj}_gmMask.nii.gz -overwrite

# Resample to functional space
3dresample -overwrite -master $func_run -inset ${subj}_gmMask.nii.gz -prefix ${subj}_${func_str}_gmMask_func.nii.gz

# Dilate mask by 1 functional voxel (just in case the resampled anatomical mask is off by a bit)
3dLocalstat -overwrite -nbhd 'SPHERE(-1)' -stat 'max' -prefix ${subj}_${func_str}_gmMask_func_dil1vox.nii.gz ${subj}_${func_str}_gmMask_func.nii.gz

rm -f ${subj}mask_temp.nii.gz

####################################################################################################
### Create white matter masks
echo "Creating white matter masks for subject ${subj}..."

# Indicate the mask value set for wmparc.nii.gz: white matter mask set
maskValSet="250 251 252 253 254 255 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 4000 4001 4002 4003 4004 4005 4006 4007 4008 4009 4010 4011 4012 4013 4014 4015 4016 4017 4018 4019 4020 4021 4022 4023 4024 4025 4026 4027 4028 4029 4030 4031 4032 4033 4034 4035 5001 5002"

# Add segments to mask
maskNum=1
for maskval in $maskValSet
do
if [ ${maskNum} = 1 ]; then
        3dcalc -a $segparc -expr "equals(a,${maskval})" -prefix ${subj}mask_temp.nii.gz -overwrite
    else
        3dcalc -a $segparc -b ${subj}mask_temp.nii.gz -expr "equals(a,${maskval})+b" -prefix ${subj}mask_temp.nii.gz -overwrite
    fi
let maskNum++
done

# Make mask binary
3dcalc -a ${subj}mask_temp.nii.gz -expr 'ispositive(a)' -prefix ${subj}_wmMask.nii.gz -overwrite

# Resample to functional space
3dresample -overwrite -master $func_run -inset ${subj}_wmMask.nii.gz -prefix ${subj}_${func_str}_wmMask_func.nii.gz

# Subtract graymatter mask from white matter mask (avoiding negative #s)
3dcalc -a ${subj}_${func_str}_wmMask_func.nii.gz -b ${subj}_${func_str}_gmMask_func_dil1vox.nii.gz -expr 'step(a-b)' -prefix ${subj}_${func_str}_wmMask_func_eroded.nii.gz -overwrite

rm -f ${subj}mask_temp.nii.gz

####################################################################################################
### Create ventricle masks
echo "Creating ventricle matter masks for subject ${subj}..."

# Indicate the mask value set for wmparc.nii.gz: ventricle mask set
maskValSet="4 43 14 15"

# Add segments to mask
maskNum=1
for maskval in $maskValSet
do
if [ ${maskNum} = 1 ]; then
        3dcalc -a $segparc -expr "equals(a,${maskval})" -prefix ${subj}mask_temp.nii.gz -overwrite
    else
        3dcalc -a $segparc -b ${subj}mask_temp.nii.gz -expr "equals(a,${maskval})+b" -prefix ${subj}mask_temp.nii.gz -overwrite
    fi
let maskNum++
done

# Make mask binary
3dcalc -a ${subj}mask_temp.nii.gz -expr 'ispositive(a)' -prefix ${subj}_ventricles.nii.gz -overwrite

# Resample to functional space
3dresample -overwrite -master $func_run -inset ${subj}_ventricles.nii.gz -prefix ${subj}_${func_str}_ventricles_func.nii.gz

# Subtract graymatter mask from ventricles (avoiding negative #s)
3dcalc -a ${subj}_${func_str}_ventricles_func.nii.gz -b ${subj}_${func_str}_gmMask_func_dil1vox.nii.gz -expr 'step(a-b)' -prefix ${subj}_${func_str}_ventricles_func_eroded.nii.gz -overwrite

rm -f ${subj}mask_temp.nii.gz

####################################################################################################